#!/bin/bash
#
# Voice dictation transcription worker - runs in background
#
# Usage: voice-dictation-transcribe <session_dir>
#
# This script is spawned by voice-dictation after recording stops.
# It transcribes the audio and pastes the result to the target tmux pane.
#

set -e

SESSION_DIR="$1"
MODEL="${WHISPER_MODEL:-whisper-large-v3-turbo}"
STATE_DIR="${XDG_RUNTIME_DIR:-/tmp}/voice-dictation"
SESSIONS_DIR="$STATE_DIR/sessions"

# Notification IDs
NOTIFY_ID_TRANSCRIBE=91002

# -----------------------------------------------------------------------------
# Utilities
# -----------------------------------------------------------------------------

get_groq_api_key() {
    local cache_file="${XDG_RUNTIME_DIR:-/tmp}/groq-api-key"
    local cache_ttl=3600  # 1 hour

    # Use cached key if fresh
    if [[ -f "$cache_file" ]]; then
        local age=$(($(date +%s) - $(stat -c %Y "$cache_file" 2>/dev/null || echo 0)))
        if [[ $age -lt $cache_ttl ]]; then
            cat "$cache_file"
            return 0
        fi
    fi

    # Fetch from bws and cache
    local key
    key=$(bws secret list 2>/dev/null | jq -r '.[] | select(.key == "GROQ_API_KEY") | .value' 2>/dev/null)
    if [[ -z "$key" || "$key" == "null" ]]; then
        return 1
    fi
    echo "$key" > "$cache_file"
    chmod 600 "$cache_file"
    echo "$key"
}

notify() {
    local msg="$1"
    local id="${2:-0}"
    local urgency="${3:-normal}"
    dunstify -r "$id" -u "$urgency" -t 2000 "Voice Dictation" "$msg" 2>/dev/null || \
        notify-send -t 2000 -u "$urgency" "Voice Dictation" "$msg" 2>/dev/null || true
}

polybar_update() {
    local state="$1"
    case "$state" in
        recording)
            polybar-msg action voice-dictation hook 1 2>/dev/null || true
            ;;
        transcribing)
            polybar-msg action voice-dictation hook 2 2>/dev/null || true
            ;;
        idle|*)
            polybar-msg action voice-dictation hook 0 2>/dev/null || true
            ;;
    esac
}

count_active_transcriptions() {
    local count=0
    for dir in "$SESSIONS_DIR"/*/; do
        [ -d "$dir" ] || continue
        if [ -f "$dir/status" ]; then
            local status
            status=$(cat "$dir/status" 2>/dev/null || echo "")
            if [ "$status" = "transcribing" ]; then
                ((count++)) || true
            fi
        fi
    done
    echo "$count"
}

update_polybar_state() {
    local active
    active=$(count_active_transcriptions)
    if [ "$active" -gt 0 ]; then
        polybar_update transcribing
    else
        polybar_update idle
    fi
}

pane_exists() {
    local pane_id="$1"
    [ -n "$pane_id" ] && tmux list-panes -a -F '#{pane_id}' 2>/dev/null | grep -q "^${pane_id}$"
}

exit_copy_mode() {
    local pane_id="$1"
    # Check if pane is in copy mode and exit if so
    local mode
    mode=$(tmux display-message -t "$pane_id" -p '#{pane_mode}' 2>/dev/null || echo "")
    if [ "$mode" = "copy-mode" ]; then
        tmux send-keys -t "$pane_id" q 2>/dev/null || true
        sleep 0.1
    fi
}

paste_to_pane() {
    local pane_id="$1"
    local text="$2"

    # Load text into tmux buffer
    printf '%s' "$text" | tmux load-buffer -

    # Exit copy mode if active
    exit_copy_mode "$pane_id"

    # Paste from buffer and press Enter
    tmux paste-buffer -t "$pane_id" 2>/dev/null
    tmux send-keys -t "$pane_id" Enter 2>/dev/null
}

x11_window_exists() {
    local window_id="$1"
    [ -n "$window_id" ] && xdotool getwindowname "$window_id" >/dev/null 2>&1
}

type_to_x11_window() {
    local window_id="$1"
    local text="$2"

    # Capture current window for snapback
    local current_window
    current_window=$(xdotool getactivewindow 2>/dev/null || echo "")

    # Focus target window and type
    xdotool windowactivate --sync "$window_id" 2>/dev/null || return 1
    sleep 0.1
    xdotool type --delay 10 -- "$text" 2>/dev/null
    xdotool key Return 2>/dev/null

    # Restore focus to original window
    if [ -n "$current_window" ] && [ "$current_window" != "$window_id" ]; then
        sleep 0.1
        xdotool windowactivate "$current_window" 2>/dev/null || true
    fi
}

cleanup() {
    # Remove session directory
    rm -rf "$SESSION_DIR"
    # Update polybar state
    update_polybar_state
}

# -----------------------------------------------------------------------------
# Main
# -----------------------------------------------------------------------------

if [ -z "$SESSION_DIR" ] || [ ! -d "$SESSION_DIR" ]; then
    notify "Transcription failed: invalid session" "$NOTIFY_ID_TRANSCRIBE" "critical"
    exit 1
fi

AUDIO_FILE="$SESSION_DIR/recording.wav"

if [ ! -f "$AUDIO_FILE" ] || [ ! -s "$AUDIO_FILE" ]; then
    notify "Transcription failed: no audio" "$NOTIFY_ID_TRANSCRIBE" "critical"
    cleanup
    exit 1
fi

# Read target info
TARGET_PANE=""
TARGET_X11=""
if [ -f "$SESSION_DIR/target.pane" ]; then
    TARGET_PANE=$(cat "$SESSION_DIR/target.pane")
fi
if [ -f "$SESSION_DIR/target.x11" ]; then
    TARGET_X11=$(cat "$SESSION_DIR/target.x11")
fi

# Get Groq API key from bws
GROQ_API_KEY=$(get_groq_api_key)
if [[ -z "$GROQ_API_KEY" ]]; then
    notify "Error: GROQ_API_KEY not found in bws" "$NOTIFY_ID_TRANSCRIBE" "critical"
    cleanup
    exit 1
fi

# Transcribe with Groq Whisper API (164x real-time speed)
RESPONSE=$(curl -s -X POST "https://api.groq.com/openai/v1/audio/transcriptions" \
    -H "Authorization: Bearer $GROQ_API_KEY" \
    -H "Content-Type: multipart/form-data" \
    -F "model=$MODEL" \
    -F "file=@$AUDIO_FILE" \
    -F "response_format=json" \
    -F "language=en" \
    2>/dev/null)

# Extract text from response
TEXT=$(echo "$RESPONSE" | jq -r '.text // empty' 2>/dev/null)

# Check for API errors
if [[ -z "$TEXT" ]]; then
    ERROR=$(echo "$RESPONSE" | jq -r '.error.message // "Unknown error"' 2>/dev/null)
    notify "Transcription failed: $ERROR" "$NOTIFY_ID_TRANSCRIBE" "critical"
    cleanup
    exit 1
fi

# Clean up whitespace
TEXT=$(echo "$TEXT" | tr '\n' ' ' | sed 's/  */ /g; s/^ *//; s/ *$//')

if [ -z "$TEXT" ]; then
    notify "No speech detected" "$NOTIFY_ID_TRANSCRIBE" "low"
    cleanup
    exit 0
fi

# Always copy to clipboard as backup
printf '%s' "$TEXT" | xclip -selection clipboard 2>/dev/null || true

# Try targets in order: tmux pane > X11 window > clipboard only
DELIVERED=false

# 1. Try tmux pane (if available)
if [ -n "$TARGET_PANE" ] && pane_exists "$TARGET_PANE"; then
    if paste_to_pane "$TARGET_PANE" "$TEXT"; then
        notify "Transcribed: ${TEXT:0:50}..." "$NOTIFY_ID_TRANSCRIBE"
        DELIVERED=true
    fi
fi

# 2. Fall back to X11 window
if [ "$DELIVERED" = false ] && [ -n "$TARGET_X11" ] && x11_window_exists "$TARGET_X11"; then
    if type_to_x11_window "$TARGET_X11" "$TEXT"; then
        notify "Transcribed: ${TEXT:0:50}..." "$NOTIFY_ID_TRANSCRIBE"
        DELIVERED=true
    fi
fi

# 3. Clipboard fallback with appropriate message
if [ "$DELIVERED" = false ]; then
    if [ -n "$TARGET_PANE" ] || [ -n "$TARGET_X11" ]; then
        notify "Window closed - copied to clipboard: ${TEXT:0:40}..." "$NOTIFY_ID_TRANSCRIBE"
    else
        notify "Copied to clipboard: ${TEXT:0:50}..." "$NOTIFY_ID_TRANSCRIBE"
    fi
fi

cleanup
