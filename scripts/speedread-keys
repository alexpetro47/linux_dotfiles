#!/usr/bin/env python3
"""RSVP speed reader with curses TUI.

Centers words on screen with ORP (Optimal Recognition Point) highlight.

Keys:
  h         - skip back 5 words
  l         - skip forward 5 words
  j, [, ↓   - slow down (±10 WPM)
  k, ], ↑   - speed up (±10 WPM)
  space     - pause/resume
  e         - open in nvim
  p         - toggle preview (context line)
  :##       - jump to word number
  q, Esc    - quit
"""
import curses
import os
import re
import subprocess
import sys
import time

def _tokenize(text):
    """Split text into words with line numbers and character positions."""
    words = []
    line_nums = []
    char_positions = []  # Starting char position of each word in the stream
    line_num = 1
    char_pos = 0
    for line in text.splitlines():
        for word in re.split(r'\s+', line):
            if word:
                words.append(word)
                line_nums.append(line_num)
                char_positions.append(char_pos)
                char_pos += len(word) + 1  # word + space
        line_num += 1
    return words, line_nums, char_positions

def _orp_index(word):
    """Calculate Optimal Recognition Point (slightly left of center)."""
    length = len(word)
    if length <= 1:
        return 0
    elif length <= 5:
        return 1
    elif length <= 9:
        return 2
    elif length <= 13:
        return 3
    else:
        return 4

def _word_delay(word, base_delay):
    """Adjust delay based on word length and punctuation."""
    delay = base_delay
    # Longer words get slightly more time
    if len(word) > 8:
        delay *= 1.2
    # Punctuation at end gets pause
    if word and word[-1] in '.!?':
        delay *= 2.0
    elif word and word[-1] in ',;:':
        delay *= 1.5
    return delay

def _slugify(words, n=5):
    """Create a slug from first n words."""
    slug_words = words[:n]
    # Remove punctuation, lowercase, join with underscores
    slug = "_".join(re.sub(r'[^\w]', '', w).lower() for w in slug_words if w)
    return slug[:50] if slug else "untitled"

def main(stdscr, filepath, initial_wpm):
    # Setup curses
    curses.curs_set(0)  # Hide cursor
    curses.use_default_colors()

    # Initialize colors
    curses.start_color()
    curses.init_pair(1, curses.COLOR_RED, -1)      # ORP highlight
    curses.init_pair(2, curses.COLOR_WHITE, -1)    # Normal text
    curses.init_pair(3, curses.COLOR_CYAN, -1)     # Status bar

    stdscr.nodelay(True)  # Non-blocking input
    stdscr.timeout(10)    # 10ms timeout for getch

    # Read and tokenize file
    with open(filepath, 'r') as f:
        text = f.read()
    words, line_nums, char_positions = _tokenize(text)
    # Build the full text stream for teleprompter preview
    text_stream = " ".join(words)

    if not words:
        stdscr.addstr(0, 0, "No words found in file")
        stdscr.refresh()
        stdscr.getch()
        return

    # State
    wpm = initial_wpm
    word_idx = 0
    paused = False
    last_frame_time = time.time()
    last_word_time = last_frame_time
    show_preview = False
    command_mode = False
    command_buffer = ""
    scroll_offset = 0.0  # Continuous character position for smooth teleprompter

    while True:
        height, width = stdscr.getmaxyx()
        center_y = height // 2
        center_x = width // 2

        # Current word
        word = words[word_idx] if word_idx < len(words) else ""
        orp = _orp_index(word)

        # Calculate position to center ORP at screen center
        word_start_x = center_x - orp

        # Clear and draw
        stdscr.erase()

        # Draw guide lines (subtle) - only when not in preview mode
        guide_y = center_y
        if width > 10 and not show_preview:
            stdscr.addstr(guide_y - 1, center_x, "▼", curses.color_pair(3) | curses.A_DIM)
            stdscr.addstr(guide_y + 1, center_x, "▲", curses.color_pair(3) | curses.A_DIM)

        # Draw word with ORP highlight (only when not in preview mode)
        if not show_preview and word and word_start_x >= 0 and word_start_x + len(word) < width:
            for i, char in enumerate(word):
                x = word_start_x + i
                if i == orp:
                    stdscr.addstr(center_y, x, char, curses.color_pair(1) | curses.A_BOLD)
                else:
                    stdscr.addstr(center_y, x, char, curses.color_pair(2))

        # Status bar
        progress = f"{word_idx + 1}/{len(words)}"
        status = f" {wpm} WPM | {progress} "
        if paused:
            status = " PAUSED | " + status

        status_x = max(0, width - len(status) - 1)
        if height > 1:
            stdscr.addstr(height - 1, status_x, status, curses.color_pair(3) | curses.A_DIM)

        # Command mode prompt
        if command_mode and height > 1:
            cmd_prompt = ":" + command_buffer
            stdscr.addstr(height - 1, 0, cmd_prompt, curses.color_pair(2))

        # Help hint
        if height > 2:
            hint = "h/l: ±5 | j/k: speed | space: pause | p: preview | e: edit | q: quit"
            hint_x = max(0, (width - len(hint)) // 2)
            stdscr.addstr(0, hint_x, hint, curses.color_pair(3) | curses.A_DIM)

        # Preview: teleprompter-style smooth scrolling (constant rate, no highlighting)
        if show_preview and height > 2:
            # Extract viewport from text stream, centered on scroll position
            half_width = width // 2
            start = max(0, int(scroll_offset) - half_width)
            end = min(len(text_stream), int(scroll_offset) + half_width)
            viewport = text_stream[start:end]

            # Draw viewport centered on screen
            viewport_x = max(0, (width - len(viewport)) // 2)
            try:
                stdscr.addstr(center_y, viewport_x, viewport, curses.color_pair(2))
            except curses.error:
                pass  # Ignore if exceeds screen

        stdscr.refresh()

        # Handle input
        try:
            key = stdscr.getch()
        except curses.error:
            key = -1

        if key != -1:
            # Command mode input handling
            if command_mode:
                if key == 27:  # Escape - cancel
                    command_mode = False
                    command_buffer = ""
                elif key in (10, 13, curses.KEY_ENTER):  # Enter - execute
                    if command_buffer.isdigit():
                        target = int(command_buffer) - 1  # 1-indexed to 0-indexed
                        word_idx = max(0, min(len(words) - 1, target))
                        scroll_offset = float(char_positions[word_idx])
                        last_word_time = time.time()
                        paused = True
                    command_mode = False
                    command_buffer = ""
                elif key == curses.KEY_BACKSPACE or key == 127:  # Backspace
                    command_buffer = command_buffer[:-1]
                elif 48 <= key <= 57:  # 0-9
                    command_buffer += chr(key)
                continue  # Skip normal key handling when in command mode

            if key in (ord('q'), 27):  # q or Esc
                break
            elif key == ord(':'):
                command_mode = True
                command_buffer = ""
                paused = True  # Pause while entering command
            elif key == ord(' '):
                paused = not paused
            elif key in (ord('j'), ord('['), curses.KEY_DOWN):
                wpm = max(50, wpm - 10)
            elif key in (ord('k'), ord(']'), curses.KEY_UP):
                wpm = min(1500, wpm + 10)
            elif key == ord('h'):
                word_idx = max(0, word_idx - 5)
                scroll_offset = float(char_positions[word_idx])
                last_word_time = time.time()
            elif key == ord('l'):
                word_idx = min(len(words) - 1, word_idx + 5)
                scroll_offset = float(char_positions[word_idx])
                last_word_time = time.time()
            elif key == ord('p'):
                show_preview = not show_preview
            elif key == ord('e'):
                # Determine file to edit
                if filepath.startswith('/tmp/speedread-clipboard'):
                    # Clipboard content - create named file
                    slug = _slugify(words)
                    target = f"/tmp/{slug}.md"
                    with open(target, 'w') as f:
                        f.write(text)
                else:
                    target = filepath
                # Suspend curses, open nvim at current line (centered), then restore
                curses.endwin()
                line = line_nums[word_idx] if word_idx < len(line_nums) else 1
                pos_file = '/tmp/speedread-nvim-pos'
                # Autocmd saves cursor line on exit
                subprocess.run([
                    'nvim', f'+{line}', '-c', 'normal zz',
                    '-c', f'autocmd VimLeave * call writefile([line(".")], "{pos_file}")',
                    target
                ])
                # Resume from nvim cursor position
                if os.path.exists(pos_file):
                    try:
                        with open(pos_file) as pf:
                            target_line = int(pf.read().strip())
                        os.remove(pos_file)
                        # Find first word on target_line
                        for i, ln in enumerate(line_nums):
                            if ln >= target_line:
                                word_idx = i
                                scroll_offset = float(char_positions[word_idx])
                                break
                    except (ValueError, IOError):
                        pass  # Keep current position on error
                last_word_time = time.time()
                stdscr.refresh()
                curses.curs_set(0)
                paused = True  # Pause after returning
            elif key == curses.KEY_RESIZE:
                stdscr.clear()

        # Update timing and scroll
        now = time.time()
        frame_delta = now - last_frame_time
        last_frame_time = now

        # Advance scroll and word if not paused
        if not paused and word_idx < len(words):
            # Scroll at constant rate: ~5 chars per word average
            chars_per_second = (wpm * 5.5) / 60.0
            scroll_offset += chars_per_second * frame_delta
            scroll_offset = min(scroll_offset, len(text_stream))

            # Advance word based on timing (separate from scroll)
            base_delay = 60.0 / wpm
            delay = _word_delay(word, base_delay)

            if now - last_word_time >= delay:
                word_idx += 1
                last_word_time = now

                # End of text
                if word_idx >= len(words):
                    paused = True
                    word_idx = len(words) - 1

def run():
    if len(sys.argv) < 2:
        print("Usage: speedread-keys <file> [wpm]", file=sys.stderr)
        sys.exit(1)

    filepath = sys.argv[1]
    wpm = int(sys.argv[2]) if len(sys.argv) > 2 else 440

    if not os.path.isfile(filepath):
        print(f"File not found: {filepath}", file=sys.stderr)
        sys.exit(1)

    curses.wrapper(lambda stdscr: main(stdscr, filepath, wpm))

if __name__ == "__main__":
    run()
